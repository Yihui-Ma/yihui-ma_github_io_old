<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yihui-Ma">





<title>Lattice Boltzmann Method | YIHUI</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="YIHUI" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Bentham&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Bentham&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Lattice Boltzmann Method</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Yihui-Ma</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 10, 2019&nbsp;&nbsp;19:32:47</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/Fluid/">Fluid</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>&emsp;&emsp;在介观方法中，LB方法逐渐被采用为模拟大范围的非单相流动的一种替代的方法。采用简单的动力学方法来模拟水动力系统的理论基础是基于自然宏观现象的观测，如水动力，对于其潜在的微观动力细节方面是相当不敏感的。在水动力系统下，微观动力的细节可以影响运输系数的数值，但是不影响Navier-Stokes equations 的整体形式。</p>
<p>&emsp;&emsp;LB方法，因此，是一种离散玻尔兹曼方程（discrete Boltzmann equation）的极小的形式，在极小的Kn数下主要地重构了Navier-Stokes级别的水动力。它是极小的，因为只有一小部分的离散值$v$→$v_i$从速度空间中保留，这些都要求满足守恒定律并且能够复原正确的空间-时间对称性（space-time symmetries）（伽利略，移动和旋转不变性(Galilean, translational and rotational invariance)）。这使得LB方法成为一种间接的N-S求解器。此外，LB方法也可以容纳描述了许多复杂流动现象的粒子间力(inter-particle force)，并且不用必须求解复杂的动力方程或者它们的分子动力。因此，LB方法适合求解包含了表面动力的问题，微粒的&#x2F;悬浮的流动（particulate&#x2F;suspension flows），多相流动（multiphase flows），Kn-过渡流动（Kn-transition flows），多孔介质流动（porous media flows）和二元复杂流动（binary complex flows）及三元复杂流动（ternary complex flows）等。值得讨论的是LB方法的多种天性是一种优点，但是同时，关于它的适用性也是一个潜在的困惑来源。</p>
<h2 id="基于LGCA的方程（LGCA-based-formulation）"><a href="#基于LGCA的方程（LGCA-based-formulation）" class="headerlink" title="基于LGCA的方程（LGCA-based formulation）"></a>基于LGCA的方程（LGCA-based formulation）</h2><p>&emsp;&emsp;LB方法来自于它的前身——格子气细胞自动机（LGCA），尤其是FHP模型，相当独立于动力学理论。LGCA背后的基本思想是在一个微观格子上的伪粒子的微观相互作用可以导致平均宏观方程组。对于相互作用，由粒子伴随着格子速度的碰撞（streaming）和传播（propagation）（或流动 (streaming)）过程组成，格子（离散的）对称性在质量守恒方面起到了一个关键作用，并且保证了角动量守恒。但是，FHP模型具有一些缺点，如统计噪声，缺乏伽利略不变性，低雷诺数要求，三维空间难以拓展等。LB方法便是为了解决LGCA的这些问题而出现的。通过一系列的里程碑式的进步，如布尔变量被实值变量替换，碰撞操作符的线性化等，LBM-BGK（LBGK）模型领域的发展，都成功地解决了LGCA的缺点。值得注意的是原始的LBM方程（由Qian和Chen等人提出）受限于等温低马赫数（近似不可压缩(near-incompressible)）流动，并且不提供一种得到非等温LBM模型的系统性的方法（也需要满足能量守恒）。早期的LB模型，由LGCA推导得出，有时候被认为是LB模型的第一代。</p>
<center>
<img src="https://raw.githubusercontent.com/Yihui-Ma/MarkdownImages/master/Lattice%20Boltzmann%20Method/FHP%20model.png" style="zoom:30%">
<div>
FHP模型图
</div>
</center>

<h2 id="连续性基于玻尔兹曼-BGK的构想-（Continuous-Boltzmann-BGK-based-formulation）"><a href="#连续性基于玻尔兹曼-BGK的构想-（Continuous-Boltzmann-BGK-based-formulation）" class="headerlink" title="连续性基于玻尔兹曼-BGK的构想 （Continuous Boltzmann-BGK based formulation）"></a>连续性基于玻尔兹曼-BGK的构想 （Continuous Boltzmann-BGK based formulation）</h2><p>&emsp;&emsp;基于LGCA的方程并没有一个与玻尔兹曼方程或者气体动力学理论相关的正式联系。与LGCA之间的联系不存在被开创性论文（由Abe，He和Luo）证明了，其中LB方法由（连续）Boltzmann-BGK方程的直接相位-空间离散化所导出。即，LB方法被证明是连续的Boltzmann-BGK方程的一种特殊的有限差分形式。即使生成的方法保持了之前基于LGCA构想（formulation）的结构形式，它在数学形式上是严谨的，（部分地）与动力学理论一致，并且具有更好的稳定性和准确性。更重要的是，这一构想使得LB方法能够通过自适应网格和非笛卡尔坐标网格等，大规模拓展到实际的工程流动问题中。但是，正如基于LGCA的构想，由于在实现推导过程中的小马赫数假设（近似不可压缩），这一构想主要受限于等温（isothermal），低速(low-speed)流动。基于He和Luo的构想的LB模型被称为第二代LB模型。</p>
<p>以上都引用自：</p>
<blockquote>
<p>Kinetically Consistent Thermal Lattice Boltzmann Models  -by Parthib R. Rao, B.Tech, National Institute of Technology, Calicut, India, 2004</p>
</blockquote>
<h2 id="Weighted-multiple-relaxation-time-WMRT-model"><a href="#Weighted-multiple-relaxation-time-WMRT-model" class="headerlink" title="Weighted multiple-relaxation-time (WMRT) model"></a>Weighted multiple-relaxation-time (WMRT) model</h2><p>&emsp;&emsp;The MRT-LBE approach is based on projection theory: the advection process of the particle distribution function is carried out in the particle velocity space, whereas the collision process is done in moment space, i.e., the distribution function is projected to its velocity moments during the collision precess.（MRT-LBE方法是基于投影理论的：粒子分布函数的传播过程是在粒子速度空间下实现的，其中碰撞过程是在矩空间实现的，如，碰撞过程中的分布函数投影到速度矩上）。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Yihui-Ma</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/08/10/Lattice-Boltzmann-Method/">http://yoursite.com/2019/08/10/Lattice-Boltzmann-Method/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/Fluid/"># Fluid</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/08/16/%E5%90%B4%E6%81%A9%E8%BE%BE%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E7%AC%94%E8%AE%B0/">吴恩达——机器学习系列课程 笔记</a>
            
            
            <a class="next" rel="next" href="/2019/08/10/%E4%BD%BF%E7%94%A8%E4%BB%8B%E8%A7%82%E6%96%B9%E6%B3%95%EF%BC%88Mesoscale-Methods%EF%BC%89%E7%9A%84%E5%8E%9F%E5%9B%A0/">使用介观方法（Mesoscale Methods）的原因</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Yihui-Ma | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>